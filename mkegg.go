package main

import (
	"bufio"
	"flag"
	"fmt"
	"github.com/johan-bolmsjo/errors"
	"io"
	"io/ioutil"
	"os"
)

func main() {
	pkgName := os.Getenv("GOPACKAGE")
	if pkgName == "" {
		fatalln("Environment variable GOPACKAGE is not set!\nPerhaps the command was not invoked by go:generate?")
	}

	var dataFilename, accessorName string

	const dataFlag = "data"
	const nameFlag = "name"

	flag.StringVar(&dataFilename, dataFlag, "", "Input data file")
	flag.StringVar(&accessorName, nameFlag, "", "Accessor function name and prefix of generated source file")
	flag.Parse()

	// The std:flag package has misguided ideas about all arguments being optional.
	// That's just not the case for many applications.
	if dataFilename == "" {
		fatalln("missing command line argument: " + dataFlag)
	}
	if accessorName == "" {
		fatalln("missing command line argument: " + nameFlag)
	}

	data, err := ioutil.ReadFile(dataFilename)
	if err != nil {
		fatalln(err)
	}

	outputFilename := accessorName + ".go"

	outputFile, err := os.Create(outputFilename)
	if err != nil {
		fatalln(err)
	}

	var es errors.Sink
	bufioWriter := bufio.NewWriter(outputFile)

	es.Send(generateOutputFile(bufioWriter, pkgName, accessorName, data))
	es.Send(bufioWriter.Flush())
	es.Send(outputFile.Close())

	if !es.Ok() {
		fatalln(errors.Wrapf(es.Cause(), "failed to generate %s", outputFilename))
	}
}

func generateOutputFile(w io.Writer, pkgName, accessorName string, data []byte) error {
	var es errors.Sink

	printf := func(format string, a ...interface{}) bool {
		if es.Ok() {
			_, err := fmt.Fprintf(w, format, a...)
			es.Send(err)
		}
		return es.Ok()
	}

	sliceName := "private_" + accessorName

	const preambleFormat = `// Code generated by mkegg; DO NOT EDIT
package %s

import "bytes"

var %s = [...]byte{`

	printf(preambleFormat, pkgName, sliceName)

	if len(data) > 0 {
		printf("\n")

		col := 0
		endi := len(data) - 1

		for i, ch := range data {
			if col == 0 {
				printf("\t%d", ch)
			} else {
				printf(",%d", ch)
			}
			col++
			if col == 101 || i == endi {
				printf(",\n")
				col = 0
			}
		}
	}

	const postambleFormat = `}

func %s() *bytes.Reader {
	return bytes.NewReader(%s[:])
}
`

	printf(postambleFormat, accessorName, sliceName)
	return es.Cause()
}

func fatalln(a ...interface{}) {
	fmt.Fprintln(os.Stderr, a...)
	os.Exit(1)
}
